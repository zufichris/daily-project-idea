# Self-Optimizing Traffic Light Simulator

## Overview

This project simulates a simplified traffic intersection with self-optimizing traffic light control. The goal is to develop a simulation that can adapt its traffic light timings based on real-time traffic flow, minimizing wait times and improving overall throughput. This project focuses on a core algorithm and doesn't require sophisticated visualization.

## Technologies & Tools

- **Programming Language:** Python
- **Libraries:** `numpy` (for numerical computation), `matplotlib` (optional, for basic visualization)
- **IDE:** Any Python IDE (e.g., VS Code, PyCharm)

## Features & Requirements

- **Traffic Flow Simulation:** Simulate vehicles arriving at the intersection randomly, with adjustable arrival rates.
- **Traffic Light Control:** Implement a basic traffic light controller with customizable cycle lengths.
- **Optimization Algorithm:**  Implement a simple optimization algorithm (e.g., a greedy approach) to adjust traffic light timings based on queue lengths at each approach.
- **Performance Metrics:**  Calculate and display average wait times and throughput.
- **Data Logging:** Log key simulation parameters (arrival rates, wait times, cycle lengths) for analysis.


- **Advanced Feature 1:**  Incorporate a more sophisticated optimization algorithm (e.g., Q-learning or a simple genetic algorithm).
- **Advanced Feature 2:** Simulate different types of vehicles (e.g., cars, buses, emergency vehicles) with varying priorities.

## Implementation Steps

1. **Basic Simulation Setup:** Create classes to represent vehicles and the intersection. Implement random vehicle generation and basic movement logic.
2. **Simple Traffic Light Controller:** Implement a fixed-cycle traffic light controller.  Focus on accurately modeling vehicle movement through the intersection given the light states.
3. **Optimization Algorithm Implementation:** Implement a simple greedy algorithm that adjusts traffic light timings based on queue lengths.  Prioritize the longest queues.
4. **Performance Measurement:**  Add code to calculate and display average wait times and throughput.
5. **Data Logging & Analysis:**  Log simulation data to a file for later analysis and visualization (optional using `matplotlib`).

## Challenges & Considerations

- **Algorithm Design:** Choosing and implementing an effective optimization algorithm within the time constraint requires careful consideration of complexity. A simpler, greedy approach is recommended for a 1-2 day timeframe.
- **Parameter Tuning:** Finding optimal parameters for the simulation (arrival rates, cycle lengths, algorithm parameters) might require experimentation and iteration.


## Learning Outcomes

- **Algorithm Design & Implementation:**  Reinforce skills in designing and implementing optimization algorithms.
- **Simulation Development:** Gain experience in building and analyzing a discrete-event simulation.

