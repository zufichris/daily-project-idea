# Self-Optimizing Traffic Light Simulation

## Overview

This project aims to build a simplified simulation of a traffic intersection, incorporating a self-optimizing control system for traffic light timings. The simulation will focus on minimizing wait times for vehicles while avoiding gridlock.  This is a valuable exercise in applying control algorithms and performance analysis to a real-world problem within a limited timeframe.

## Technologies & Tools

- **Programming Language:** Python
- **Libraries:**  NumPy (for numerical computation), Matplotlib (for visualization), SimPy (for discrete event simulation)


## Features & Requirements

- **Traffic Generation:**  Simulate vehicle arrival at each approach to the intersection using a configurable arrival rate.
- **Traffic Light Control:** Implement a basic traffic light controller with configurable cycle lengths and green-light durations.
- **Performance Metrics:** Track and display metrics such as average waiting time, queue lengths, and throughput.
- **Self-Optimization:** Implement a simple optimization algorithm (e.g., a proportional-integral controller or a reinforcement learning agent, simplified) that adjusts traffic light timings based on real-time traffic conditions.
- **Visualization:**  Create a visual representation of the intersection, vehicle movements, and traffic light states.

- **Advanced Features (Optional):** Incorporate different vehicle types with varying speeds and lengths. Implement a more sophisticated optimization algorithm.

## Implementation Steps

1. **Set up the simulation environment:**  Import necessary libraries, define vehicle and intersection parameters (number of lanes, arrival rates, etc.), and initialize SimPy processes for vehicle generation.
2. **Implement the basic traffic light controller:** Create a simple round-robin or fixed-time controller to manage traffic light switching.
3. **Integrate performance metrics:** Track average waiting time, queue length, and throughput. Implement basic visualization using Matplotlib to display these metrics.
4. **Develop the self-optimization algorithm:** Implement a simple proportional-integral (PI) controller that adjusts green-light durations based on queue lengths at each approach. Alternatively, begin implementing a simplified Q-learning agent for a more advanced challenge.
5. **Combine and test:** Integrate the controller, optimization algorithm, and visualization to test the simulation's performance under various traffic conditions.


## Challenges & Considerations

- **Algorithm complexity:**  Balancing the complexity of the optimization algorithm with the time constraint is crucial. Starting with a simple PI controller is recommended before attempting a reinforcement learning approach.
- **Parameter tuning:** Finding optimal parameter settings for the traffic generation and the optimization algorithm may require iterative testing and adjustment.


## Learning Outcomes

- Reinforcement of discrete event simulation techniques using SimPy.
- Practical application of control algorithms (PI control or basic reinforcement learning) for real-world system optimization.

