# Mini-Game AI:  Procedural Level Generation for a Simple 2D Platformer

## Overview
This project aims to develop a simple 2D platformer game with procedurally generated levels using a lightweight AI. The focus is on rapid prototyping and demonstrating basic AI techniques for level design, rather than creating a full-fledged game.  The significance lies in showcasing the power of procedural generation to create diverse and replayable game content within a short timeframe.


## Technologies & Tools
- Programming Language: Python
- Game Library: Pygame
- AI Library:  Optional - a simple library like `numpy` for random number generation and basic array manipulation.


## Features & Requirements
- **Procedural Level Generation:** The game should generate a new level each time it starts, using simple algorithms to place platforms, obstacles, and a goal.
- **Simple Physics Engine:** Basic platformer physics should be implemented (gravity, jumping, collision detection).
- **Player Control:**  The player should be controllable using arrow keys or WASD.
- **Win Condition:** The player wins by reaching the goal.
- **Level Difficulty Scaling:** The level should increase slightly in complexity with each playthrough (e.g., more platforms, more obstacles).

- **Advanced Feature 1:** Implement a basic enemy AI that patrols along a simple path.
- **Advanced Feature 2:**  Add a simple scoring system based on time taken or collectibles collected.


## Implementation Steps
1. **Basic Game Structure:** Set up a Pygame window, create the player sprite, and implement basic movement.
2. **Level Generation Algorithm:**  Develop a simple algorithm to randomly generate platform positions and heights.  Consider using a tile-based approach for simplicity.
3. **Collision Detection:** Implement basic collision detection between the player and platforms.
4. **Goal Implementation:**  Place a goal at the end of the procedurally generated level.  Implement win condition logic.
5. **Difficulty Scaling:** Introduce a simple mechanism to incrementally increase the level complexity (e.g., adding more platforms or obstacles).


## Challenges & Considerations
- **Algorithm Complexity:** Balancing level complexity and generation speed. A overly complex algorithm might take too long to execute, hindering the daily challenge timeframe.  Keeping the generation simple is key.
- **Collision Detection Robustness:** Ensuring accurate and efficient collision detection, especially with increasing level complexity.  A simple bounding box approach is sufficient for this daily challenge.


## Learning Outcomes
- Reinforcing procedural generation techniques for creating dynamic game content.
- Practicing basic game development principles, including sprite manipulation, collision detection, and input handling.

